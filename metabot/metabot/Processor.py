import sys
import time

from pywikiapi import Site, AttrDict
from pywikibot import Site as PbSite

from .consts import Q_TAG
from .ProcessorItem import ProcessorItem
from .Properties import P_INSTANCE_OF, P_KEY_ID, P_TAG_ID, P_TAG_KEY
from .utils import get_entities, list_to_dict_of_lists


class Processor:

    def __init__(self, opts, cache, site: Site, pb_site: PbSite) -> None:
        self.opts = AttrDict(opts)
        self.cache = cache
        self.site = site
        self.pb_site = pb_site

        wiki_items = (
                []
                + self.cache.keydescription.get()
                + self.cache.tagdescription.get()
        )

        existing_items_strids = set(self.cache.itemKeysByStrid.get().keys())

        self.new_items_strids = set([v.str_id for v in wiki_items
                                # if 'direction' in v.str_id  #DEBUG
                                ]) - existing_items_strids

        self.autogenerated_keys = set()
        self.all_items_by_strid = {
            **self.items_by_strid(P_KEY_ID, reload_on_error=False),
            **self.items_by_strid(P_TAG_ID, reload_on_error=False),
        }

        self.wiki_items_by_id = list_to_dict_of_lists(wiki_items, lambda v: v.str_id)

        self.tags_per_key = list_to_dict_of_lists(
            self.cache.data_items.get(),
            lambda v: P_TAG_KEY.get_claim_value(v) if P_INSTANCE_OF.get_claim_value(v) == Q_TAG else None)

    def items_by_strid(self, prop, fix_multiple=False, reload_on_error=True):
        result = {}
        errors_fixed = False
        for item in self.cache.data_items.get():
            qid = item.id
            try:
                values = prop.get_claim_value(item, allow_multiple=True)
                if not values or len(values) == 0:
                    continue
                if len(values) == 1:
                    result[values[0]] = item
                    continue
                if reload_on_error:
                    # reload and re-parse item just in case we had stale data
                    print(f'Multiple keys found in { self.qitem(qid)}, reloading')
                    item = get_entities(self.site, qid)
                    if item:
                        values = prop.get_claim_value(item, allow_multiple=True)
                        if not values or len(values) == 0:
                            continue
                        if len(values) == 1:
                            result[values[0]] = item
                            continue
                if not fix_multiple:
                    raise ValueError('Found multiple key ids ')
                if len(set(values)) > 1:
                    raise ValueError('Found multiple different keys')

                print(f'Removing multiple duplicate keys from { self.qitem(qid)}...')
                raise ValueError('Not implemented')
                # if not self.allow_edit(prop, qid):
                #     continue
                # pbitem = pb.ItemPage(self.pb_site, qid)
                # pbitem.get()
                # pbitem.removeClaims(pbitem.claims[prop.id][1:], summary="Removed duplicate keys")
                # errors_fixed = True

            except ValueError as err:
                print(f'Error parsing key id from { self.qitem(qid)}: {err}')

        if errors_fixed:
            time.sleep(5)
            self.cache.items.regenerate()
            return self.items_by_strid(prop, fix_multiple=False, reload_on_error=False)
        else:
            return result

    def run(self, mode):
        if mode == 'new':
            items = self.new_items_strids
        elif mode == 'old':
            items = self.cache.itemKeysByStrid.get()
        elif mode == 'autogen_keys':
            items = self.autogenerated_keys
        else:
            raise ValueError(f'Unknown mode {mode}')

        for source in items:
            for item in source:
                try:
                    if item:
                        pc = ProcessorItem(self, item)
                        pc.run()
                except:
                    print(f'Crashed while processing "{item}": ', sys.exc_info()[0])
                    if self.opts['throw']:
                        raise
