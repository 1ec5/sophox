import difflib

import pywikibot as pb
from pywikiapi import AttrDict
from typing import Dict, List

from .Properties import P_INSTANCE_OF, P_KEY_ID, P_TAG_ID, P_TAG_KEY, P_KEY_TYPE, Property, P_LANG_CODE, ClaimValue, \
    P_LIMIT_TO
from .consts import Q_KEY, Q_TAG, Q_ENUM_KEY_TYPE, Q_LOCALE_INSTANCE
from .utils import get_sitelink, list_to_dict_of_lists, sitelink_normalizer_key, sitelink_normalizer_tag

known_non_enums = {
    'name',  # Many POIs use Tag:name=*
}


class UploadItem:
    claims: Dict[Property, List[ClaimValue]]

    def __init__(self, caches, autogenerated_keys, pb_site, strid, item, editData,
                 claims: Dict[Property, List[ClaimValue]],
                 opts, dry_run) -> None:
        self.messages = []
        self.caches = caches
        self.opts = opts
        self.autogenerated_keys = autogenerated_keys
        self.qitem = caches.qitem
        self.pb_site = pb_site
        self.strid = strid
        self.item = item
        self.editData = editData
        self.claims = claims
        self.dry_run = dry_run
        self.needs_changes = False
        self.mod_claims = {}
        self.duplicates = {}
        self.force_contribs = not dry_run
        self.rank_updated = False

        if not self.item:
            self.item = AttrDict()
            self.item.labels = {}
            self.item.descriptions = {}
            self.qid = None
        else:
            self.qid = self.item.id

    def prepare_upload(self):
        try:
            if self.qid:
                self.validate_data_item()

            self.update_i18n('labels')
            self.update_i18n('descriptions')

            if 'en' in self.item.descriptions and \
                    self.item.descriptions.en == self.strid and \
                    ('descriptions' not in self.editData or 'en' not in self.editData['descriptions']):
                self.editData['descriptions']['en'] = ''

            self.update_claims()

            self.check_user_modifications()

            self.needs_changes = len(self.editData['labels']) > 0 or \
                                 len(self.editData['descriptions']) > 0 or \
                                 len(self.editData['sitelinks']) > 0 or \
                                 len(self.mod_claims) > 0 or len(self.duplicates) > 0
        except:
            self.print_messages()
            self.needs_changes = False
            raise

    def prohibit(self, type, value):
        if not self.item or not self.qid:
            return False
        force = self.force_contribs
        contribs = self.caches.contributed(self.item.id, force=force)
        self.force_contribs = False
        return type in contribs and value in contribs[type]

    def check_user_modifications(self):
        if not self.qid:
            # new item
            return

        labels = self.editData['labels']
        if not self.opts.overwrite_user_labels_en and 'en' in labels and self.prohibit('label', 'en'):
            self.print(f'User modified item: cannot set en label to "{self.editData["labels"]["en"]}"')
            del labels['en']
        if not self.opts.overwrite_user_labels:
            for lng in list(labels.keys()):
                if lng != 'en' and self.prohibit('label', lng):
                    if self.editData["labels"][lng]:
                        self.print(f'User modified item: cannot set {lng} label to "{self.editData["labels"][lng]}"')
                    del labels[lng]

        descriptions = self.editData['descriptions']
        if not self.opts.overwrite_user_descriptions and descriptions:
            for lng in list(descriptions.keys()):
                if lng in self.item.descriptions and self.prohibit('description', lng):
                    if descriptions[lng]:
                        self.print(f'User modified item: cannot set description {lng} '
                                   f'"{self.item.descriptions[lng]["value"]}" ==> "{descriptions[lng]}"')
                    del descriptions[lng]

        if not self.opts.overwrite_user_claims and (self.mod_claims or self.duplicates):
            for op, lst in [('mod', self.mod_claims), ('fix', self.duplicates)]:
                for clm in lst:
                    if self.prohibit('claim', clm):
                        self.print(f'User modified item: cannot {op} claim {clm}')
                        del lst[clm]

    def upload_item_updates(self):
        self.print(('Updating ' if self.qid else 'Creating ') + \
                   (self.strid or '') + ' ' + self.qitem(self.qid))
        summary = ''
        if not self.qid:
            pb_item = pb.ItemPage(self.pb_site)
        else:
            pb_item = pb.ItemPage(self.pb_site, self.qid)
            pb_item.get()
        data = self.editData
        if data['labels']:
            summary += 'labels ' + ', '.join([f"{k}:'{v}'" for k, v in data['labels'].items()])
        if data['descriptions']:
            if summary: summary += ' '
            summary += ', '.join([f"{k}:'{v}'" for k, v in data['descriptions'].items()])

        self.print(summary)
        for prop in self.claims.keys():
            self.apply_claims(pb_item, prop)

        self.print_messages()
        if not self.qid:
            pb_item.editEntity(data, summary=summary)
        else:
            if data['labels'] or data['descriptions'] or data['sitelinks']:
                pb_item.editEntity({
                    'labels': data['labels'],
                    'descriptions': data['descriptions'],
                    'sitelinks': data['sitelinks'],
                })
            if self.rank_updated:
                def order(value):
                    key = value[0]
                    prop_order = ['P2', 'P3', 'P16', 'P9', 'P19', 'P10', 'P4', 'P28', 'P6',
                                  'P33', 'P34', 'P35', 'P36', 'P37', 'P25']
                    try:
                        return prop_order.index(key)
                    except ValueError:
                        return int(key[1:]) + 10000

                pb_item.claims = {v[0]: v[1] for v in sorted(pb_item.claims.items(), key=order)}
                pb_item.editEntity()

        self.print_messages()
        for prop in self.duplicates:
            self.fix_duplicates(pb_item, prop)

        self.print_messages()
        self.print(f'+++ Data item {self.strid} updated!')

    def update_claims(self):
        for prop in self.claims.keys():
            old_claim_vals = prop.get_claim_value(self.item, allow_multiple=True, allow_qualifiers=True) or []
            new_claim_vals = self.claims[prop]
            if old_claim_vals != new_claim_vals:
                self.mod_claims[prop] = new_claim_vals

                status = f'  {prop}' if not self.qid else f"{self.qitem(self.qid)} {prop}\n"
                old_strs = list(map(str, old_claim_vals))
                new_strs = list(map(str, new_claim_vals))
                status += '  ' + '\n  '.join([
                    f"\x1b[{'32;107' if s.startswith('+') else '31;107' if s.startswith('-') else '0'}m{s}\x1b[0m"
                    for s in difflib.ndiff(old_strs, new_strs) if not s.startswith('?')
                ])
                self.print(status)

            # add = set(new_claim_vals) - set(old_claim_vals)
            # if add:
            #     status += f" = { self.qitem(add) }"
            #     self.add_claims[prop] = add
            # remove = set(old_claim_vals) - set(new_claim_vals)
            # if remove:
            #     status += f"   removing { self.qitem(remove) }"
            #     self.del_claims[prop] = remove
            # if add or remove:
            #     self.print(status)

    def update_i18n(self, type):
        if type not in self.item:
            return
        good_langs = set()
        if type in self.editData:
            langs = list(self.editData[type])
            for lang in langs:
                new_val = self.editData[type][lang]
                if lang in self.item[type]:
                    old_val = self.item[type][lang].value
                    if old_val != new_val:
                        self.print(f'{type[:-1]} {lang}: {old_val} -> {new_val}')
                    else:
                        good_langs.add(lang)
                        del self.editData[type][lang]

        for lang in self.item[type].keys():
            if lang == 'en' and type == 'labels':
                continue
            if lang in good_langs:
                continue
            if type not in self.editData or lang not in self.editData[type]:
                self.editData[type][lang] = ''

    def validate_data_item(self):
        item = self.item
        item_as_str = self.qitem(self.qid)
        instance_of = P_INSTANCE_OF.get_claim_value(item)
        key_strid = P_KEY_ID.get_claim_value(item)
        tag_strid = P_TAG_ID.get_claim_value(item)
        tag_key = P_TAG_KEY.get_claim_value(item)
        sitelink = get_sitelink(item)
        edit_sitelink = self.editData['sitelinks'][0]['title']
        item_is_key = None
        item_is_tag = None

        if instance_of == Q_LOCALE_INSTANCE:
            locale_id = P_LANG_CODE.get_claim_value(item)
            exp_sitelink = ('Locale:' + locale_id.lower()).strip()
            if not sitelink or sitelink != exp_sitelink:
                item.sitelinks = [{'site': 'wiki', 'title': exp_sitelink}]
                sitelink = exp_sitelink
                self.rank_updated = True
            else:
                self.editData['sitelinks'] = []

        if instance_of == Q_KEY or key_strid or \
                (sitelink and sitelink.startswith('Key:')) or \
                (edit_sitelink and edit_sitelink.startswith('Key:')):
            # Must be a key
            item_is_key = True
            if not instance_of:
                self.print(f"{item_as_str} seems to be a key, but instance_of is not set")
                self.claims[P_INSTANCE_OF] = [ClaimValue(Q_KEY)]
            elif instance_of != Q_KEY:
                self.print(f"{item_as_str} seems to be a key, but instance_of is {instance_of}")
                item_is_key = False
            if not key_strid:
                self.print(f"{item_as_str} seems to be a key, but {P_KEY_ID} is not set")
                self.claims[P_KEY_ID] = [ClaimValue(self.strid)]
            elif '=' in key_strid:
                self.print(f"{item_as_str} seems to be a key, but {key_strid} has '=' in it")
                item_is_key = False
            if tag_strid:
                self.print(f"{item_as_str} seems to be a key, but {P_TAG_ID} must not set")
            if tag_key:
                self.print(f"{item_as_str} seems to be a key, but {P_TAG_KEY} must not set")
                item_is_key = False

            expected_sitelink = sitelink_normalizer_key(self.strid)
            if not sitelink:
                self.print(f"{item_as_str} seems to be a key, but sitelink is not set")
                item.sitelinks = [{'site': 'wiki', 'title': expected_sitelink}]
            elif not sitelink.startswith('Key:') or (key_strid and expected_sitelink != sitelink):
                self.print(f"{item_as_str} seems to be a key, but sitelink equals to {sitelink}")
                if sitelink.startswith('Tag:') or '=' in sitelink:
                    item_is_key = False
            if expected_sitelink != edit_sitelink:
                raise ValueError(f'Expected sitelink {expected_sitelink} != {edit_sitelink}')
            if sitelink == edit_sitelink:
                self.editData['sitelinks'] = []

            related_tags = self.caches.tags_per_key[self.qid] if self.qid in self.caches.tags_per_key else []
            if len(related_tags) > 5 and key_strid not in known_non_enums:
                self.claims[P_KEY_TYPE] = [ClaimValue(Q_ENUM_KEY_TYPE)]

        if instance_of == Q_TAG or tag_strid or \
                (sitelink and sitelink.startswith('Tag:')) or \
                (edit_sitelink and edit_sitelink.startswith('Tag:')):
            # Must be a tag
            item_is_tag = True
            if not instance_of:
                self.print(f"{item_as_str} seems to be a tag, but instance_of is not set")
                self.claims[P_INSTANCE_OF] = [ClaimValue(Q_TAG)]
            elif instance_of != Q_TAG:
                self.print(f"{item_as_str} seems to be a tag, but instance_of is {instance_of}")
                item_is_tag = False
            if not tag_strid:
                self.print(f"{item_as_str} seems to be a tag, but {P_TAG_ID} is not set")
                self.claims[P_TAG_ID] = [ClaimValue(self.strid)]
            elif '=' not in tag_strid:
                self.print(f"{item_as_str} seems to be a tag, but {tag_strid} has no '=' in it")
                item_is_tag = False
            if key_strid:
                self.print(f"{item_as_str} seems to be a tag, but {P_KEY_ID} must not be set")
                item_is_tag = False

            ks = (tag_strid or self.strid).split('=')[0]
            expected_tag_key = self.caches.itemKeysByStrid.get_strid(ks)

            if not tag_key:
                self.print(f"{item_as_str} seems to be a tag, but {P_TAG_KEY} is not set" +
                           (', setting to ' + self.qitem(
                               expected_tag_key) if expected_tag_key else ' (nor it could be found in the item cache)'))
                if expected_tag_key:
                    self.claims[P_TAG_KEY] = [ClaimValue(expected_tag_key)]
                else:
                    self.autogenerated_keys.add(ks)
            else:
                if not expected_tag_key:
                    self.print(f"{item_as_str} {P_KEY_ID} = {self.qitem(tag_key)}, "
                               f"but the computed key '{ks}' does not exist in the item cache")
                elif expected_tag_key != tag_key:
                    self.print(f"{item_as_str} {P_KEY_ID} = {self.qitem(tag_key)}, "
                               f"which is different from expected {self.qitem(expected_tag_key)}")
            if tag_key in self.caches.itemByQid.get():
                tag_key_item = self.caches.itemByQid.get()[tag_key]
                if P_INSTANCE_OF.get_claim_value(tag_key_item) != Q_KEY:
                    self.print(f"{item_as_str} {P_KEY_ID} = {self.qitem(tag_key)}, "
                               f"which is not a key")
                if P_KEY_ID.get_claim_value(tag_key_item) != ks:
                    self.print(f"{item_as_str} {P_KEY_ID} = {self.qitem(tag_key)}, "
                               f"which does not have its key id set to {ks}")

            expected_sitelink = sitelink_normalizer_tag(self.strid)
            if not sitelink:
                self.print(f"{item_as_str} seems to be a tag, but sitelink is not set")
                item.sitelinks = [{'site': 'wiki', 'title': expected_sitelink}]
            elif not sitelink.startswith('Tag:') or (tag_strid and expected_sitelink != sitelink):
                self.print(f"{item_as_str} seems to be a tag, but sitelink equals to {sitelink}")
                if sitelink.startswith('Key:') or '=' not in sitelink:
                    item_is_tag = False
            if expected_sitelink != edit_sitelink:
                raise ValueError(f'Expected sitelink {expected_sitelink} != {edit_sitelink}')
            if sitelink == edit_sitelink:
                self.editData['sitelinks'] = []

        if item_is_key == False or item_is_tag == False:
            raise ValueError(f'{item_as_str} needs manual fixing')

        # Fix multiple values
        for prop in Property.ALL.values():
            if not prop.allow_multiple:
                vals = prop.get_claim_value(item, allow_multiple=True, allow_qualifiers=True)
                if vals:
                    vals = list_to_dict_of_lists(vals, lambda v: v.rank)
                    if 'preferred' in vals:
                        vals2 = vals['preferred']
                        if len(vals2) > 1:
                            self.print(f"{item_as_str} property {prop} has multiple preferred values:")
                            self.print('  ' + '\n  '.join([str(v) for v in vals2]))
                        with_qlf = [v for v in vals2 if v.qualifiers and len(v.qualifiers) > 0]
                        if len(with_qlf) > 0:
                            self.print(f"{item_as_str} property {prop} has preferred values with qualifier:")
                            self.print('  ' + '\n  '.join([str(v) for v in with_qlf]))
                    if 'normal' in vals:
                        vals2 = vals['normal']
                        if len(vals2) > 1:
                            qualifiers = [v.qualifiers[P_LIMIT_TO]
                                          for v in vals2 if v.qualifiers and P_LIMIT_TO in v.qualifiers]
                            unique = set()
                            for qlf in qualifiers:
                                unique.update(qlf)
                            if sum([len(v) for v in qualifiers]) != len(unique):
                                self.print(f"{item_as_str} property {prop} has multiple normal values:")
                                self.print('  ' + '\n  '.join([str(v) for v in vals2]))
                        # self.duplicates[prop] = True

    def print(self, msg):
        self.messages.append(msg)

    def print_messages(self):
        if self.messages:
            print(f'---- {self.strid}  {self.item.id if self.item and "id" in self.item else ""}')
            for msg in self.messages:
                print(msg)
            self.messages = []

    def apply_claims(self, pb_item: pb.ItemPage, prop: Property):
        add_values = self.mod_claims[prop] if prop in self.mod_claims else None
        if not add_values:
            return
        if not self.qid:
            for v in add_values:
                prop.set_claim_on_new(self.editData, v)
            return

        add_values = {v.value: v for v in add_values}

        if prop.id in pb_item.claims:
            delete_claims = []
            for old_claim in pb_item.claims[prop.id]:
                old_value = prop.value_from_claim(old_claim)
                if old_value in add_values:
                    new_value = add_values[old_value]
                    del add_values[old_value]
                    self.merge_claim(old_claim, new_value)
                else:
                    delete_claims.append(old_claim)
            if delete_claims:
                pb_item.removeClaims(delete_claims)
        if add_values:
            for v in add_values.values():
                claim = prop.create_claim(self.pb_site, v)
                self.rank_updated = True
                pb_item.addClaim(claim)
                self.add_new_qualifiers(claim, v)

    def merge_claim(self, claim: pb.Claim, new_value: ClaimValue):
        if claim.getRank() != new_value.rank:
            self.rank_updated = True
            claim.setRank(new_value.rank)
        delete_qualifiers = []
        for qualifier_prop_id, qualifier_vals in list(claim.qualifiers.items()):
            qprop = Property.ALL[qualifier_prop_id]
            if qprop not in new_value.qualifiers:
                delete_qualifiers += claim.qualifiers[qualifier_prop_id]
            else:
                new_q_vals = new_value.qualifiers[qprop]
                for q_val, q in list_to_dict_of_lists(qualifier_vals, lambda v: qprop.value_from_claim(v)).items():
                    if len(q) != 1:
                        raise ValueError(f'Unexpected number of identical qualifier values found for {qprop} / {q_val}')
                    if q_val in new_q_vals:
                        new_q_vals.remove(q_val)
                    else:
                        delete_qualifiers.append(q[0])
                for new_q_val in new_q_vals:
                    claim.addQualifier(qprop.create_claim(self.pb_site, new_q_val))
                    self.rank_updated = True
        if delete_qualifiers:
            claim.removeQualifiers(delete_qualifiers)
        self.add_new_qualifiers(claim, new_value)

    def add_new_qualifiers(self, claim, new_value):
        for q_prop, qualifier_vals in new_value.qualifiers.items():
            for v in qualifier_vals:
                claim.addQualifier(q_prop.create_claim(self.pb_site, v))
                self.rank_updated = True

    def fix_duplicates(self, pb_item, prop):
        if prop.id in pb_item.claims:
            vals = set()
            remove = []
            for c in pb_item.claims[prop.id]:
                val = prop.value_from_claim(c)
                if val in vals:
                    remove.append(c)
                else:
                    vals.add(val)
            if remove:
                pb_item.removeClaims(remove)

    def create_language_region(self, lang_code, label, description):
        pb_item = pb.ItemPage(self.pb_site)
        data = {
            'labels': {'en': label},
            'descriptions': {'en': description},
            'sitelinks': {'wiki': 'Locale:' + lang_code}
        }
        P_INSTANCE_OF.set_claim_on_new(data, Q_LOCALE_INSTANCE)
        P_LANG_CODE.set_claim_on_new(data, lang_code)
        pb_item.editEntity(data, summary=label)
