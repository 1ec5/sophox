import pywikibot as pb
from pywikiapi import AttrDict

from .Properties import P_USED_ON, P_NOT_USED_ON, P_OSM_IMAGE, P_IMAGE, P_GROUP, P_STATUS, P_INSTANCE_OF, \
    P_KEY_ID, P_TAG_ID, P_TAG_KEY, P_KEY_TYPE, Property
from .consts import elements, Q_KEY, Q_TAG, Q_ENUM_KEY_TYPE
from .utils import get_sitelink, list_to_dict_of_lists, reTag_repl, remove_wikimarkup, sitelink_normalizer_key, \
    sitelink_normalizer_tag

known_non_enums = {
    'name',  # Many POIs use Tag:name=*
}


class UploadItem:

    def __init__(self, caches, autogenerated_keys, pb_site, strid, item, editData, claims, opts,
                 dry_run) -> None:
        self.messages = []
        self.caches = caches
        self.opts = opts
        self.autogenerated_keys = autogenerated_keys
        self.qitem = caches.qitem
        self.pb_site = pb_site
        self.strid = strid
        self.item = item
        self.editData = editData
        self.claims = claims
        self.dry_run = dry_run
        self.needs_changes = False
        self.add_claims = {}
        self.del_claims = {}
        self.duplicates = {}
        self.force_contribs = not dry_run

        if not self.item:
            self.item = AttrDict()
            self.item.labels = {}
            self.item.descriptions = {}
            self.qid = None
        else:
            self.qid = self.item.id

    def prepare_upload(self):
        try:
            if self.qid:
                self.validate_data_item()

            self.update_i18n('labels')
            self.update_i18n('descriptions')

            if 'en' in self.item.descriptions and \
                    self.item.descriptions.en == self.strid and \
                    ('descriptions' not in self.editData or 'en' not in self.editData['descriptions']):
                self.editData['descriptions']['en'] = ''

            self.update_claims()

            self.check_user_modifications()

            self.needs_changes = len(self.editData['labels']) > 0 or \
                                 len(self.editData['descriptions']) > 0 or \
                                 'sitelinks' in self.editData or \
                                 len(self.add_claims) > 0 or len(self.del_claims) > 0 or len(self.duplicates) > 0
        except:
            self.print_messages()
            self.needs_changes = False
            raise

    def prohibit(self, type, value):
        if not self.item:
            return False
        force = self.force_contribs
        contribs = self.caches.contributed(self.item.id, force=force)
        self.force_contribs = False
        return type in contribs and value in contribs[type]

    def check_user_modifications(self):
        labels = self.editData['labels']
        if not self.opts.overwrite_user_labels_en and 'en' in labels and self.prohibit('label', 'en'):
            self.print(f'User modified item: cannot set en label to "{self.editData["labels"]["en"]}"')
            del labels['en']
        if not self.opts.overwrite_user_labels:
            for lng in list(labels.keys()):
                if lng != 'en' and self.prohibit('label', lng):
                    if self.editData["labels"][lng]:
                        self.print(f'User modified item: cannot set {lng} label to "{self.editData["labels"][lng]}"')
                    del labels[lng]

        descriptions = self.editData['descriptions']
        if not self.opts.overwrite_user_descriptions and descriptions:
            for lng in list(descriptions.keys()):
                if lng in self.item.descriptions and self.prohibit('description', lng):
                    if descriptions[lng]:
                        self.print(f'User modified item: cannot set description {lng} '
                                   f'"{self.item.descriptions[lng]["value"]}" ==> "{descriptions[lng]}"')
                    del descriptions[lng]

        if not self.opts.overwrite_user_claims and (self.add_claims or self.del_claims or self.duplicates):
            for op, lst in [('add', self.add_claims), ('del', self.del_claims), ('fix', self.duplicates)]:
                for clm in lst:
                    if self.prohibit('claim', clm):
                        self.print(f'User modified item: cannot {op} claim {clm}')
                        del lst[clm]

    def upload_item_updates(self):
        self.print(('Updating ' if self.qid else 'Creating ') + self.strid + ' ' + self.qitem(self.qid))
        summary = ''
        if not self.qid:
            pb_item = pb.ItemPage(self.pb_site)
        else:
            pb_item = pb.ItemPage(self.pb_site, self.qid)
            pb_item.get()
        if self.editData['labels']:
            summary += 'labels ' + ', '.join([f"{k}:'{v}'" for k, v in self.editData['labels'].items()])
        if self.editData['descriptions']:
            if summary: summary += ' '
            summary += ', '.join([f"{k}:'{v}'" for k, v in self.editData['descriptions'].items()])
        for prop_id in self.claims.keys():
            self.apply_claims(pb_item, Property.ALL[prop_id])
        for prop_id in self.duplicates:
            self.fix_duplicates(pb_item, Property.ALL[prop_id])
        self.print(summary)
        self.print_messages()
        pb_item.editEntity(self.editData, summary=summary)
        self.print(f'+++ Data item {self.strid} updated!')

    def update_claims(self):
        for prop_id in self.claims.keys():
            prop = Property.ALL[prop_id]
            allow = self.allow_edit(prop)
            old_claim_vals = prop.get_claim_value(self.item, True) or []
            new_claim_vals = self.claims[prop.id]
            changed = False
            status = f'  {prop}' if not self.qid else f"{ self.qitem(self.qid) } {prop}"

            vals = set(new_claim_vals) - set(old_claim_vals)
            if vals:
                status += f" = { self.qitem(vals) }"
                if allow:
                    self.add_claims[prop.id] = vals
                    changed = True

            vals = set(old_claim_vals) - set(new_claim_vals)
            if vals:
                status += f"   removing { self.qitem(vals) }"
                if allow:
                    self.del_claims[prop.id] = vals
                    changed = True

            if changed:
                self.print(status)

    def update_i18n(self, type):
        if type not in self.item:
            return
        good_langs = set()
        if type in self.editData:
            langs = list(self.editData[type])
            for lang in langs:
                new_val = self.editData[type][lang]
                if lang in self.item[type]:
                    old_val = self.item[type][lang].value
                    if old_val != new_val:
                        self.print(f'{type[:-1]} {lang}: {old_val} -> {new_val}')
                    else:
                        good_langs.add(lang)
                        del self.editData[type][lang]

        for lang in self.item[type].keys():
            if lang == 'en' and type == 'labels':
                continue
            if lang in good_langs:
                continue
            if type not in self.editData or lang not in self.editData[type]:
                self.editData[type][lang] = ''

    def validate_data_item(self):
        item = self.item
        item_as_str = self.qitem(self.qid)
        instance_of = P_INSTANCE_OF.get_claim_value(item)
        key_strid = P_KEY_ID.get_claim_value(item)
        tag_strid = P_TAG_ID.get_claim_value(item)
        tag_key = P_TAG_KEY.get_claim_value(item)
        sitelink = get_sitelink(item)
        edit_sitelink = self.editData['sitelinks'][0]['title']
        item_is_key = None
        item_is_tag = None

        if instance_of == Q_KEY or key_strid or \
                (sitelink and sitelink.startswith('Key:')) or \
                (edit_sitelink and edit_sitelink.startswith('Key:')):
            # Must be a key
            item_is_key = True
            if not instance_of:
                self.print(f"{item_as_str} seems to be a key, but instance_of is not set")
                self.claims[P_INSTANCE_OF.id] = [Q_KEY]
            elif instance_of != Q_KEY:
                self.print(f"{item_as_str} seems to be a key, but instance_of is {instance_of}")
                item_is_key = False
            if not key_strid:
                self.print(f"{item_as_str} seems to be a key, but {P_KEY_ID} is not set")
                self.claims[P_KEY_ID.id] = [self.strid]
            elif '=' in key_strid:
                self.print(f"{item_as_str} seems to be a key, but {key_strid} has '=' in it")
                item_is_key = False
            if tag_strid:
                self.print(f"{item_as_str} seems to be a key, but {P_TAG_ID} must not set")
            if tag_key:
                self.print(f"{item_as_str} seems to be a key, but {P_TAG_KEY} must not set")
                item_is_key = False

            expected_sitelink = sitelink_normalizer_key(self.strid)
            if not sitelink:
                self.print(f"{item_as_str} seems to be a key, but sitelink is not set")
            elif not sitelink.startswith('Key:') or (key_strid and expected_sitelink != sitelink):
                self.print(f"{item_as_str} seems to be a key, but sitelink equals to {sitelink}")
                if sitelink.startswith('Tag:') or '=' in sitelink:
                    item_is_key = False
            if expected_sitelink != edit_sitelink:
                raise ValueError(f'Expected sitelink {expected_sitelink} != {edit_sitelink}')
            if sitelink == edit_sitelink:
                del self.editData['sitelinks']

            related_tags = self.caches.tags_per_key[self.qid] if self.qid in self.caches.tags_per_key else []
            if len(related_tags) > 5 and key_strid not in known_non_enums:
                self.claims[P_KEY_TYPE.id] = [Q_ENUM_KEY_TYPE]

        if instance_of == Q_TAG or tag_strid or \
                (sitelink and sitelink.startswith('Tag:')) or \
                (edit_sitelink and edit_sitelink.startswith('Tag:')):
            # Must be a tag
            item_is_tag = True
            if not instance_of:
                self.print(f"{item_as_str} seems to be a tag, but instance_of is not set")
                self.claims[P_INSTANCE_OF.id] = [Q_TAG]
            elif instance_of != Q_TAG:
                self.print(f"{item_as_str} seems to be a tag, but instance_of is {instance_of}")
                item_is_tag = False
            if not tag_strid:
                self.print(f"{item_as_str} seems to be a tag, but {P_TAG_ID} is not set")
                self.claims[P_TAG_ID.id] = [self.strid]
            elif '=' not in tag_strid:
                self.print(f"{item_as_str} seems to be a tag, but {tag_strid} has no '=' in it")
                item_is_tag = False
            if key_strid:
                self.print(f"{item_as_str} seems to be a tag, but {P_KEY_ID} must not be set")
                item_is_tag = False

            ks = (tag_strid or self.strid).split('=')[0]
            expected_tag_key = self.caches.itemKeysByStrid.get_strid(ks)

            if not tag_key:
                self.print(f"{item_as_str} seems to be a tag, but {P_TAG_KEY} is not set" +
                           (', setting to ' + self.qitem(
                               expected_tag_key) if expected_tag_key else ' (nor it could be found in the item cache)'))
                if expected_tag_key:
                    self.claims[P_TAG_KEY.id] = [expected_tag_key]
                else:
                    self.autogenerated_keys.add(ks)
            else:
                if not expected_tag_key:
                    self.print(f"{item_as_str} {P_KEY_ID} = { self.qitem(tag_key) }, "
                               f"but the computed key '{ks}' does not exist in the item cache")
                elif expected_tag_key != tag_key:
                    self.print(f"{item_as_str} {P_KEY_ID} = { self.qitem(tag_key) }, "
                               f"which is different from expected { self.qitem(expected_tag_key) }")
            if tag_key in self.caches.itemByQid.get():
                tag_key_item = self.caches.itemByQid.get()[tag_key]
                if P_INSTANCE_OF.get_claim_value(tag_key_item) != Q_KEY:
                    self.print(f"{item_as_str} {P_KEY_ID} = { self.qitem(tag_key) }, "
                               f"which is not a key")
                if P_KEY_ID.get_claim_value(tag_key_item) != ks:
                    self.print(f"{item_as_str} {P_KEY_ID} = { self.qitem(tag_key) }, "
                               f"which does not have its key id set to {ks}")

            expected_sitelink = sitelink_normalizer_tag(self.strid)
            if not sitelink:
                self.print(f"{item_as_str} seems to be a tag, but sitelink is not set")
            elif not sitelink.startswith('Tag:') or (tag_strid and expected_sitelink != sitelink):
                self.print(f"{item_as_str} seems to be a tag, but sitelink equals to {sitelink}")
                if sitelink.startswith('Key:') or '=' not in sitelink:
                    item_is_tag = False
            if expected_sitelink != edit_sitelink:
                raise ValueError(f'Expected sitelink {expected_sitelink} != {edit_sitelink}')
            if sitelink == edit_sitelink:
                del self.editData['sitelinks']

        if item_is_key == False or item_is_tag == False:
            raise ValueError(f'{item_as_str} needs manual fixing')

        # Fix multiple values
        for prop in Property.ALL.values():
            if not prop.allow_multiple:
                vals = prop.get_claim_value(item, allow_multiple=True)
                if vals and len(vals) > 1:
                    self.print(f"{item_as_str} property {prop} has multiple values: {','.join(vals)}")
                    if len(set(vals)) == 1:
                        self.duplicates[prop.id] = True

    def print(self, msg):
        self.messages.append(msg)

    def print_messages(self):
        if self.messages:
            print(f'---- {self.strid}  {self.item.id if self.item and "id" in self.item else ""}')
            for msg in self.messages:
                print(msg)
            self.messages = []

    def apply_claims(self, pb_item, prop):
        add_claims = self.add_claims[prop.id] if prop.id in self.add_claims else False
        del_claims = self.del_claims[prop.id] if prop.id in self.del_claims else False

        if add_claims:
            for v in add_claims:
                if self.qid:
                    pb_item.addClaim(prop.create_claim(self.pb_site, v))
                else:
                    prop.set_claim_on_new(self.editData, v)
        if del_claims and self.qid and prop.id in pb_item.claims:
            remove = [c for c in pb_item.claims[prop.id] if prop.value_from_claim(c) in del_claims]
            if remove:
                pb_item.removeClaims(remove)

    def fix_duplicates(self, pb_item, prop):
        if prop.id in pb_item.claims:
            vals = set()
            remove = []
            for c in pb_item.claims[prop.id]:
                val = prop.value_from_claim(c)
                if val in vals:
                    remove.append(c)
                else:
                    vals.add(val)
            if remove:
                pb_item.removeClaims(remove)

    def allow_edit(self, prop):
        if (self.opts.props and prop.id not in self.opts.props) or \
                (self.opts.ignore_qid and self.qid in self.opts.ignore_qid):
            self.print(f'***********************  Skipping { self.qitem(self.qid) } '
                       f'prop {prop} due to parameter restrictions.')
            return False
        return True

    #
    #
    #
    #
    #
    #
    #
    #
    #
    #
    #
    #

    # def process_wiki_pages(self):
    #     self.merge_wiki_languages()
    #     if (not self.qid and 'en' not in self.new_labels) or (self.get_localized_value('labels', 'en') != self.strid):
    #         self.new_labels['en'] = self.strid
    #     if P_IMAGE.id in self.claims and P_OSM_IMAGE.id in self.claims:
    #         del self.claims[P_OSM_IMAGE.id]
    #     if self.has_unknown_group:
    #         status = ''
    #         old_group = P_GROUP.get_claim_value(self.item)
    #         if old_group:
    #             status += ' Currently set to ' + self.qitem(old_group)
    #         new_groups = self.claims[P_GROUP.id] if P_GROUP.id in self.claims else None
    #         if new_groups and {old_group} != set(new_groups):
    #             status += ' Trying to set to: ' + self.qitem(set(new_groups.values()))
    #         if status:
    #             self.print(status)
    #     if self.new_labels or self.new_descrs:
    #         status = f"{self.strid} - { self.qitem(self.qid) }"
    #         other_editors = self.get_nonbot_editors()
    #         if not other_editors:
    #             status = ('Updating ' if self.qid else 'Creating ') + status
    #         else:
    #             status = f'Cannot update {status} because it was edited by {other_editors}'
    #         self.print('***************** ' + status)
    #
    #         def lbls_to_status(name, old, new):
    #             results = []
    #             for k, v in new.items():
    #                 res = f"{k}="
    #                 prefixlen = len(res)
    #                 if old and k in old:
    #                     res += f"'{old[k]['value']}' -> "
    #                 if len(res) > 30:
    #                     res += '\n' + (' ' * (prefixlen + 2))
    #                 res += f"'{v}'"
    #                 results.append(res)
    #
    #             return (name +
    #                     (': ' if len(results) == 1 else ':\n    ') +
    #                     '\n    '.join(results))
    #
    #         if self.new_labels:
    #             self.print(lbls_to_status('  labels', self.item.labels, self.new_labels))
    #         if self.new_descrs:
    #             self.print(lbls_to_status('  descrs', self.item.descriptions, self.new_descrs))
    #
    #         if not other_editors:
    #             if self.qid:
    #                 summary = 'Updating'
    #             else:
    #                 pb_item = pb.ItemPage(self.pb_site)
    #                 summary = 'Creating'
    #             if self.new_labels:
    #                 summary += ' labels ' + ', '.join([f"{k}:'{v}'" for k, v in self.new_labels.items()])
    #                 self.editData.labels = self.new_labels
    #             if self.new_descrs:
    #                 summary += ' descriptions ' + ', '.join([f"{k}:'{v}'" for k, v in self.new_descrs.items()])
    #                 self.editData.descriptions = self.new_descrs
    #
    #             if not self.qid:
    #                 pt = next(iter(self.proc.wiki_items_by_id[self.strid]))
    #                 if pt.type == 'Key':
    #                     self.editData.sitelinks = [{'site': 'wiki', 'title': sitelink_normalizer_key(self.strid)}]
    #                     P_INSTANCE_OF.set_claim_on_new(self.editData, Q_KEY)
    #                     P_KEY_ID.set_claim_on_new(self.editData, self.strid)
    #                 elif pt.type == 'Tag':
    #                     self.editData.sitelinks = [{'site': 'wiki', 'title': sitelink_normalizer_tag(self.strid)}]
    #                     P_INSTANCE_OF.set_claim_on_new(self.editData, Q_TAG)
    #                     P_TAG_ID.set_claim_on_new(self.editData, self.strid)
    #
    #                     ek = self.caches.itemKeysByStrid.get()
    #                     ks = self.strid.split('=')[0]
    #                     if ks in ek:
    #                         P_TAG_KEY.set_claim_on_new(self.editData, ek[ks])
    #                     else:
    #                         self.print(f"Unable to find item '{ks}' for '{self.strid}', not setting {P_TAG_KEY}")
    #                 else:
    #                     self.print(f'Unknown type {pt}, skipping')
    #                     self.qid = None
    #                     return
    #
    #                 self.apply_all_claims(self.editData)
    #
    #                 self.print(f'  +++ creating {self.strid}')
    #                 pb_item.editEntity(self.editData, summary=summary)
    #
    # def merge_wiki_languages(self):
    #     for lng, vv in list_to_dict_of_lists(self.proc.wiki_items_by_id[self.strid], lambda v: v.lang).items():
    #         if len(vv) > 1 and len(set([v.ns for v in vv])) == 1:
    #             vv = [v for v in vv if
    #                   'Key:' in v.full_title or 'Tag:' in v.full_title]
    #         if len(vv) > 1:
    #             self.print(f'Multiple descriptions found {lng} : {self.strid} { self.qitem(self.qid) }')
    #             break
    #         params = vv[0].params
    #
    #         if 'oldkey' in params:
    #             # deprecation support
    #             params.description = (deprdescr[lng] if lng in deprdescr else deprdescr['en']).replace('$1', params[
    #                 'newtext'] if 'newtext' in params else '')
    #             params.image = 'Ambox warning pn.svg'
    #             params.status = 'Deprecated'
    #
    #         self.update_text_val('label', lng, self.new_labels, params)
    #         self.do_description(lng, params)
    #         self.do_used_on(lng, params)
    #         self.do_images(lng, params)
    #         self.do_groups(lng, params)
    #         self.do_status(lng, params)
    #
    # def do_description(self, lng, params):
    #     if 'description' in params:
    #         descr = params.description
    #         if descr == '???':
    #             del params.description
    #         else:
    #             if "[[" in descr:
    #                 self.print(f"Unable to fix description {descr}")
    #             descr = descr.replace('\n', ' ')
    #             if '{{' in descr:
    #                 pass
    #             descr = reTag.sub(reTag_repl, descr)
    #             params.description = remove_wikimarkup(descr)
    #         self.update_text_val('description', lng, self.new_descrs, params)
    #
    # def do_status(self, lng, params):
    #     if 'status' in params:
    #         statuses = self.caches.statusesByName.get()
    #         st = params.status.lower()
    #         if st in statuses:
    #             self.claims[P_STATUS.id][lng] = statuses[st]
    #         elif st not in ['undefined', 'unspecified', 'unknown']:
    #             self.print(f"Unknown status {params.status} for {self.strid} ({lng})  { self.qitem(self.qid) }")
    #
    # def do_groups(self, lng, params):
    #     if 'group' in params:
    #         groups = self.caches.groupsByName.get()
    #         grp = params.group.lower()
    #         if grp in groups:
    #             self.claims[P_GROUP.id][lng] = groups[grp]
    #         else:
    #             self.print(f"Unknown group {params.group} for {self.strid} ({lng})  { self.qitem(self.qid) }")
    #             self.has_unknown_group = True
    #
    # def do_images(self, lng, params):
    #     if 'image' in params:
    #         if params.image.startswith('osm:'):
    #             self.claims[P_OSM_IMAGE.id][lng] = params.image[len('osm:'):]
    #         else:
    #             self.claims[P_IMAGE.id][lng] = params.image
    #
    # def do_used_on(self, lng, params):
    #     # Used/Not used on
    #     usedon = []
    #     notusedon = []
    #     for v in ['onnode', 'onarea', 'onway', 'onrelation', 'onclosedway', 'onchangeset']:
    #         if v in params:
    #             vv = elements[v[2:]]
    #             if params[v] == 'yes':
    #                 usedon.append(vv)
    #             elif params[v] == 'no':
    #                 notusedon.append(vv)
    #             else:
    #                 self.print(f'unknown usedon type {params[v]} for {self.strid} { self.qitem(self.qid) }')
    #     usedon.sort()
    #     notusedon.sort()
    #     if usedon: self.claims[P_USED_ON.id][lng] = usedon
    #     if notusedon: self.claims[P_NOT_USED_ON.id][lng] = notusedon
    #
    #
    # def update_text_val(self, typ, lng, newval, wikiinfo):
    #     typs = typ + 's'
    #     if typ in wikiinfo:
    #         old_value = self.get_localized_value(typs, lng)
    #         old_en_value = self.get_localized_value(typs, 'en')
    #         wikivalue = wikiinfo[typ][:250]
    #         if wikivalue != old_value:
    #             if lng != 'en':
    #                 if 'en' in newval and newval['en'] == wikivalue:
    #                     return
    #                 if old_en_value == wikivalue:
    #                     return
    #             newval[lng] = wikivalue
    #         elif lng != 'en' and old_en_value == wikivalue:
    #             # current value should be deleted
    #             newval[lng] = ''
    #
    # def get_localized_value(self, typ, lng, fallback_to_en=False):
    #     if typ in self.item:
    #         all = self.item[typ]
    #         if lng in all:
    #             return all[lng]['value']
    #         if fallback_to_en and 'en' in all:
    #             return all['en']['value']
    #     return None
    #
